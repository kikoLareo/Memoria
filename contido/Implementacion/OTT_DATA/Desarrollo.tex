\subsection{Desarrollo de la aplicación de análisis de datos}
\label{sec:desarrollo-matomo}

Una vez configurada la API de Matomo, se pueden comenzar a realizar consultas a la misma para obtener la información necesaria. 
Estos datos serán utilizados para construir las gráficas y tablas que se mostrarán en la aplicación de análisis de datos.

Para la obtención, procesamiento y gestión de los datos, se ha desarrollado la aplicación con un enfoque escalable y mantenible. 
Durante el desarrollo, se ha empleado la tecnología de React, una biblioteca de JavaScript para la creación de interfaces de usuario, 
complementada con el uso de HTML, CSS, así como diversas librerías y APIs.


\subsubsection{Estructura de la aplicación}
\label{sec:estructura-aplicacion}
La aplicación está compuesta por varios módulos, cada uno encargado de una tarea específica. La estructura de la aplicación es la siguiente:

\begin{itemize}
    \item \textbf{Configuración:} Módulo responsable de configurar la aplicación. Este módulo genera las URLs necesarias y realiza las consultas a la API de Matomo. Cada URL se construye según el módulo correspondiente de Matomo, la acción deseada y las variables necesarias para la consulta. También permite configurar qué gráficos y datos se mostrarán en cada página.
    \item \textbf{Consultas:} Módulo encargado de realizar las consultas a la API de Matomo. Contiene las funciones que ejecutan las consultas y devuelven los datos obtenidos. Para cada acción, se utiliza el módulo API y la función \textit{getProcessedReport} para obtener la información detallada de Matomo sobre cada acción.
    \item \textbf{Procesamiento:} Módulo responsable de procesar los datos obtenidos y crear las distintas páginas de la aplicación. Se solicitan los datos necesarios y se envían a los componentes de gráficas y tablas para su creación, ordenando los resultados para presentarlos en la página correspondiente.
    \item \textbf{Componentes:} Módulo que contiene los componentes de gráficas y tablas utilizados en la aplicación. Cada componente es un archivo independiente encargado de generar una gráfica o tabla específica.
    \item \textbf{Diseño:} Módulo que contiene las hojas de estilo CSS utilizadas en la aplicación para proporcionar un diseño atractivo y usable.
\end{itemize}


\subsubsection{Desarrollo de la aplicación}
\label{sec:desarrollo-aplicacion}
Para el desarrollo de la aplicación utilizando la API de Matomo, el primer paso tras configurar y preparar Matomo fue obtener un 
servidor donde alojar la aplicación, ya que por razones de seguridad, la API bloquea las consultas realizadas desde un servidor local. 
Para ello, se utilizó el servicio de Netlify \cite{netlify}, una plataforma de alojamiento de aplicaciones web que permite desplegar aplicaciones 
de manera sencilla y rápida.

Una vez alojada la aplicación, se procedió con su desarrollo. El primer paso fue trabajar en los archivos de configuración, 
los cuales se encargan de generar las URLs necesarias para realizar las consultas a la API.

\paragraph{Ejemplo de archivo de configuración de la API de Matomo}
\begin{lstlisting}[language=Java]
    const methodBase = 'MediaAnalytics';
    const module = 'API';

    export const MediaAnalytics_get = (idSite, period = 'day', date = '2023-12-01,2024-07-01') => {
        const method = `${methodBase}.get`;
        return { url: getBaseUrl(module ,method, { idSite, period, date }), title: 'Overall Metrics' };
    };

    export const MediaAnalytics_getCurrentNumPlays = async (idSite, lastMinutes = 180) => {
        const action = 'getCurrentNumPlays';
        const method = `${methodBase}.getCurrentNumPlays`;
        return await fetchData(idSite, { module: methodBase, action,url: getBaseUrl(module ,method, { idSite, lastMinutes })});
    };

\end{lstlisting}

Estos archivos reciben los parámetros necesarios para realizar las consultas a la API, crean la URL (getBaseUrl) y consiguen los
datos (fetchData) necesarios para la creación de las gráficas y tablas. 

\paragraph{Función para la creación de la URL de la API de Matomo}
\begin{lstlisting}[language=Java]
    export const getBaseUrl = (module, method, params = {}) => {
        const baseUrl = `${baseURL}index.php?module=${module}&format=${format}&method=${method}&token_auth=${token_auth}`;
        const queryParams = new URLSearchParams(params).toString();
        return `${baseUrl}&${queryParams}`;
  };
\end{lstlisting}

\paragraph{Función para la obtención de los datos de la API de Matomo}
\begin{lstlisting}[language=Java]
    
export const fetchData = async (idSite, requestData) => {
    var newChartData = null;
    try {
      try {
        let dataUrl = API_getProcessedReport(idSite, 'year', 'yesterday', requestData.module, requestData.action, language);
        let response = await axios.get(dataUrl.url);
        var processedData = response.data;
      } catch (error) {
        console.error('Error fetching data:', error);
      }
  
      // Usar la función de API general
      const response1 = await axios.get(requestData.url);
      const responseData = response1.data;
  
      const data = {
        value: responseData,
        info: processedData ? processedData : {}
      };
  
      newChartData = data;
      console.log('Data fetched:', newChartData);
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  
    return newChartData;
  };
\end{lstlisting}


Una vez obtenidos los datos y procesados según la configuración de la página correspondiente, se formatean y unifican antes de ser enviados 
a los componentes de gráficas y tablas para su creación. Tras generar los componentes, estos se añaden a la página, mostrando así los resultados.


\paragraph{Ejemplo de creación de una gráfica}
\begin{lstlisting}[language=Java]
    return (
        <div key={index} className="data-table-section">
          <h2>{chartConfig.title}</h2>
          <div className="chart-group">
            {metrics.map((metric, metricIndex) => (
              <GraphRenderer
                key={metricIndex}
                chart={{
                  type: chartConfig.type,
                  labels: labels,
                  data: dataPoints[metric],
                  title: chartConfig.metrics[metric],
                  metricType: chartConfig.data.info?.metadata.metricTypes[metric] || 'number',
                }}
              />
            ))}
          </div>
        </div>
      );
\end{lstlisting}

Para detectar los formatos y los componentes que deben crearse, se desarrolló el componente \textit{GraphRenderer}, que recibe los datos y el 
tipo de gráfica a generar, y se encarga de invocar al componente correspondiente para su creación. Este componente fue diseñado como un puente 
entre los datos y los componentes de gráficas y tablas, favoreciendo así la escalabilidad y mantenibilidad de la aplicación.


\paragraph{Código del componente GraphRenderer}
\begin{lstlisting}[language=Java]
    
    const GraphRenderer = ({ chart, chartIndex }) => {
        const { type, labels, data, title, metricType } = chart;
    
    
        switch (type) {
        case 'lineal':
            return (
            <div className="graph_component" key={chartIndex}>
                <ChartComponent
                labels={labels}
                data={data}
                label={title}
                title={title}
                metricType={metricType}
                />
            </div>
            );
    
        case 'pie':
            return (
            <div className="graph_component" key={chartIndex}>
                <PieChartComponent
                labels={labels}
                data={data}
                title={title}
                />
            </div>
            );
            ...
        }
    };
\end{lstlisting}


Para la creación de los distintos gráficos y tablas se ha utilizado la librería \textit{Chart.js} \cite{ChartJS}. Esta librería 
facilita la creación de gráficos y tablas de forma sencilla y rápida, ofreciendo una amplia gama de opciones que pueden 
personalizarse y adaptarse a las necesidades de la aplicación. Gracias a su flexibilidad, es posible generar gráficos y 
tablas ajustados a los requisitos específicos del proyecto. Hasta el momento, se han empleado los componentes \textit{Line}, 
\textit{Bar}, \textit{Pie} y \textit{Bubble} para la creación de las gráficas.


\paragraph{Ejemplo de creación de un grafico lineal}
\begin{lstlisting}[language=Java]
    
const ChartComponent = ({ data, labels, title, metricType }) => {
    const chartData = {
      labels,
      datasets: [
        {
          label: title,
          data,
          fill: false,
          backgroundColor: 'rgba(75, 192, 192, 0.6)',
          borderColor: 'rgba(75, 192, 192, 1)',
        },
      ],
    };
  
    if(metricType === 'percentage') {
      chartData.datasets[0].yAxisID = 'percentage';
    }
    const options = {
      scales: {
        x: {
          beginAtZero: true,
        },
        y: {
          beginAtZero: true,
        },
      },
    };
  
    return (
      <div className="graph">
        <h2>{title}</h2>
        <Line data={chartData} options={options} />
      </div>
    );
  };
\end{lstlisting}

Como se puede ver en el ejemplo de código, ChartJs permite la personalización de los distintos componente modificando los colores, 
títulos, ejes, etc. 

\subsubsection{Automatización y configuración de las páginas}
\label{sec:automatizacion-configuracion-paginas}

Siguiendo con el enfoque de escalabilidad y mantenibilidad de la aplicación, las páginas se han creado de forma dinámica. 
Para cada una de ellas, existe un archivo de configuración que especifica qué métodos y acciones deben ejecutarse para su 
creación. Además, se dispone de otro archivo que contiene la información básica de cada gráfica, en caso de que la llamada 
a \textit{API.getProcessedReport} no devuelva los datos necesarios. Este archivo también incluye la función que permite 
obtener la información requerida para generar dicha gráfica.

\paragraph{Ejemplo de archivo de configuración de una página}

\begin{lstlisting}[language=Java]
    export const pagesConfig = [
  {
    path: '/visitorSummary',
    title: 'Resumen del visitante',
    chartsConfig:visitCharts_summary,
    components: ["chartOptions", "DataOverviewTable", "GraphRenderer"],
  },
  {
    path: '/visitTime',
    title: 'Tiempo',
    chartsConfig: visitCharts_time,
    components: ["GraphRenderer", "periodSelecter"]
  },
  ...
];
\end{lstlisting}

\paragraph{Ejemplo de archivo de configuración de una gráfica}

\begin{lstlisting}[language=Java]
    export const visitsCharts_frequency = [
    {
      title: 'Visits - Frequency',
      description: 'Get the frequency of visits.',
      action: "get",
      module: 'Visits',
      period: 'month',
      date: '2024-03-01,yesterday',
      type: 'lineal',
      metrics: {
        "nb_visits_new" : "Nuevas visitas",
        "nb_visits_returning": "Visitas que regresan"
      },
      data : [],
      params: ["period"],
      fetchDataFunction: visitFrequency_get,
      async getData(idSite, period = this.period, date = this.date){
        this.data = await visitFrequency_get(idSite, period, date)
        if(this.data.info.metadata){
          this.description = this.data.info.metadata.documentation;
          this.title = this.data.info.metadata.name;
          this.metrics = this.data.info.columns || this.data.info.metadata.metrics || this.metrics;
        }  
        return this;
      }
      
    },
   
  ];
\end{lstlisting}

Esta función se llamará desde la página correspondiente y se comenzará el proceso de creación de las gráficas. 

\subsubsection{Context y Hooks}
\label{sec:context-hooks}

Para la gestión de los datos y la comunicación entre los distintos componentes de la aplicación, se ha utilizado la API de Context 
y Hooks de React. Context es una API que permite compartir datos entre componentes sin la necesidad de pasarlos a través de \textit{props}. 
Se crea un contexto y se envuelve la aplicación en un componente que provee dicho contexto. Los componentes que lo requieran 
podrán acceder a los datos desde este contexto.

En esta aplicación, se ha creado un contexto para la detección del \textit{id} del sitio web que se está analizando. Este \textit{id} 
es necesario para realizar consultas a la API de Matomo y obtener los datos correspondientes al sitio web.

\paragraph{Ejemplo de uso de Context:}   
\begin{verbatim}
    const { idSite } = useContext(IdSiteContext);
\end{verbatim}

Hooks es una API que permite a los componentes utilizar el estado y otras características de React sin la necesidad de escribir 
una clase. Son empleados para la gestión del estado de los componentes y la comunicación entre los mismos.

Los hooks más utilizados en esta aplicación son \texttt{useState} y \texttt{useEffect} (y \texttt{useContext} para el uso de Context del id).

\paragraph{\texttt{useState}:} Hook que permite añadir estado a los componentes funcionales y actualizarlo cuando sea necesario.
\begin{verbatim}
    const [isLoading, setIsLoading] = useState(true);
\end{verbatim}

\paragraph{\texttt{useEffect}:} Hook que permite realizar efectos secundarios en los componentes funcionales. Se ejecuta después 
de cada renderizado del componente.

\paragraph{Ejemplo de uso de \texttt{useEffect} para la actualización de los datos cuando cambia el \texttt{id} del sitio web:}
\begin{verbatim}
    useEffect(() => {
        const fetchData = async () => {
          setLoading(true);
          try {
            const evolutionData = await homeCharts_VisitsSection_Evolution.getData(idSite); 
            setVisitsEvolution(evolutionData);
          } catch (error) {
            console.error('Error fetching visits data:', error);
          } finally {
            setLoading(false);
          }
        };
        fetchData();
      }, [idSite]);
\end{verbatim}

\subsubsection{Despliegue de la aplicación}
\label{sec:despliegue-aplicacion}

A medida que se iba desarrollando la aplicación, se realizaron pruebas para asegurar su correcto funcionamiento. Para ello, 
se utilizó Postman, una herramienta que permite realizar peticiones a una API y verificar que los datos devueltos sean correctos. 
El despliegue se llevó a cabo en el servicio de Netlify \cite{netlify}, que facilita la publicación de aplicaciones web de manera rápida 
y sencilla, permitiendo comprobar que la aplicación se desplegaba correctamente. Actualmente, la aplicación sigue alojada en Netlify 
y es accesible a través de la URL \url{https://kanaloa-dev.netlify.app}.
